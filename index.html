<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>横スクロール（100体の敵 / 旗でゴール / BGM付き）</title>
<style>
  :root { --bg:#0d1117; --fg:#e6edf3; --mut:#8b949e; --acc:#58a6ff }
  html,body { height:100%; margin:0; background:var(--bg); color:var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif }
  .wrap { max-width:960px; margin:8px auto; padding:0 12px; text-align:center }
  h1 { font-size:clamp(18px,2.4vw,22px); margin:8px 0 10px }
  #game { display:block; margin:0 auto; background:#0a0f14; border:1px solid #30363d; border-radius:12px; touch-action:none }
  .hud { display:flex; gap:12px; justify-content:center; align-items:center; margin:10px 0 14px; color:var(--mut); font-size:14px; flex-wrap:wrap }
  .hud strong{ color:var(--fg) }
  .btn { display:inline-block; padding:6px 12px; border:1px solid #30363d; border-radius:8px; color:var(--fg); text-decoration:none }
  .btn:hover { background:#161b22 }
  .tips { color:var(--mut); font-size:13px }
  .vol { width:110px; vertical-align:middle }
</style>
</head>
<body>
<div class="wrap">
  <h1>横スクロール・マリオ風（100体/旗でゴール/BGM）</h1>
  <canvas id="game" width="800" height="480" aria-label="Game canvas"></canvas>
  <div class="hud">
    <div>スコア：<strong id="score">0</strong></div>
    <div>残機：<strong id="lives">3</strong></div>
    <a href="#" id="restart" class="btn">↺ リスタート(R)</a>
    <a href="#" id="pause"   class="btn">⏸ 一時停止(P)</a>
    <a href="#" id="bgmBtn"  class="btn">♪ BGM: OFF</a>
    <label>音量 <input id="vol" class="vol" type="range" min="0" max="1" step="0.01" value="0.4"></label>
  </div>
  <div class="tips">操作：←/→ or A/D で移動・スペース/Zでジャンプ（空中1回）・旗に触れるとクリア。BGMは最初のキー/クリックで開始。</div>
</div>

<script>
(()=>{
// ============== 画面・UI ==============
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', {alpha:false});
const UI = {
  score: document.getElementById('score'),
  lives: document.getElementById('lives'),
  pause: document.getElementById('pause'),
  restart: document.getElementById('restart'),
  bgmBtn: document.getElementById('bgmBtn'),
  vol: document.getElementById('vol'),
  refresh(){ this.score.textContent = score; this.lives.textContent = lives;
             this.pause.textContent = paused ? "▶ 再開(P)" : "⏸ 一時停止(P)";
             this.bgmBtn.textContent = "♪ BGM: " + (bgm.isOn ? "ON" : "OFF"); }
};

// DPI対応しつつ、幅・高さ制限にフィット
function fitCanvas(){
  const marginY = 180, AR = 480/800;
  const maxW = Math.min(960, window.innerWidth-24);
  const maxH = Math.max(320, window.innerHeight - marginY);
  let cssW = Math.min(maxW, Math.floor(maxH / AR));
  let cssH = Math.floor(cssW * AR);
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  canvas.style.width=cssW+'px'; canvas.style.height=cssH+'px';
  canvas.width = cssW*dpr; canvas.height = cssH*dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  view.w = cssW; view.h = cssH;
}
addEventListener('resize', fitCanvas);

// ============== ステージ生成 ==============
const TILE=32;
const T = { EMPTY:0, GROUND:1, BLOCK:2, FLAG:3 };
const ROWS=12, COLS=240;
let level = makeLevel();

function makeLevel(){
  const g = Array.from({length:ROWS},()=>Array(COLS).fill(T.EMPTY));
  const ground = ROWS-1;
  for(let c=0;c<COLS;c++) g[ground][c]=T.GROUND;

  // 足場（ほどよい段差）
  for(let c=10;c<COLS-20;c+=14){
    const r = ground - 3 - ((c/14)%3|0);
    g[r][c]=g[r][c+1]=g[r][c+2]=T.BLOCK;
  }
  // ゴール旗
  g[ground-2][COLS-6] = T.FLAG;
  return g;
}
function tileAt(px,py){
  if(px<0||py<0||px>=COLS*TILE||py>=ROWS*TILE) return T.GROUND;
  const c = Math.floor(px/TILE), r = Math.floor(py/TILE);
  return level[r][c];
}
function collideRectTile(rect,dx,dy){
  const nx=rect.x, ny=rect.y;
  if(dx>0){
    const x=nx+rect.w, top=Math.floor((ny+1)/TILE), bottom=Math.floor((ny+rect.h-1)/TILE);
    for(let r=top;r<=bottom;r++){
      const t = level[r]?.[Math.floor(x/TILE)];
      if(t===T.GROUND || t===T.BLOCK){ return {collide:true, snap:Math.floor(x/TILE)*TILE-rect.w}; }
    }
  } else if(dx<0){
    const x=nx, top=Math.floor((ny+1)/TILE), bottom=Math.floor((ny+rect.h-1)/TILE);
    for(let r=top;r<=bottom;r++){
      const t = level[r]?.[Math.floor((x-1)/TILE)];
      if(t===T.GROUND || t===T.BLOCK){ return {collide:true, snap:Math.floor((x-1)/TILE+1)*TILE}; }
    }
  }
  if(dy>0){
    const y=ny+rect.h, left=Math.floor((nx+3)/TILE), right=Math.floor((nx+rect.w-3)/TILE);
    for(let c=left;c<=right;c++){
      const t = level[Math.floor(y/TILE)]?.[c];
      if(t===T.GROUND || t===T.BLOCK){ return {collide:true, snap:Math.floor(y/TILE)*TILE-rect.h}; }
    }
  } else if(dy<0){
    const y=ny, left=Math.floor((nx+3)/TILE), right=Math.floor((nx+rect.w-3)/TILE);
    for(let c=left;c<=right;c++){
      const t = level[Math.floor((y-1)/TILE)]?.[c];
      if(t===T.GROUND || t===T.BLOCK){ return {collide:true, snap:Math.floor((y-1)/TILE+1)*TILE}; }
    }
  }
  return {collide:false, snap:0};
}

// ============== 物理・オブジェクト ==============
let GRAV=0.72, JUMP_V=-12.0, MOVE_A=0.9, MAX_VX=5.4;
const AIR_DRAG=0.93, GROUND_FRICTION=0.86, CUT_JUMP=0.5;

const view = {x:0,y:0,w:800,h:480};
const player = { x:TILE*2, y:TILE*(ROWS-4), w:22,h:28, vx:0,vy:0, onGround:false, canDouble:false, facing:1 };

class Goomba{
  constructor(x,y){ this.x=x; this.y=y; this.w=26; this.h=22; this.vx=-1; this.vy=0; this.alive=true; }
  update(){
    if(!this.alive) return;
    this.vy += GRAV; this.y += this.vy;
    const hy = collideRectTile(this,0,this.vy); if(hy.collide && this.vy>0){ this.y=hy.snap; this.vy=0; }
    this.x += this.vx;
    const hx = collideRectTile(this,this.vx,0); if(hx.collide){ this.x=hx.snap; this.vx*=-1; }
    if(this.y>ROWS*TILE+200) this.alive=false;
  }
  draw(){
    if(!this.alive) return;
    const x=Math.floor(this.x-view.x), y=Math.floor(this.y-view.y);
    if(x+this.w<0||x>view.w||y+this.h<0||y>view.h) return;
    ctx.fillStyle="#8B4513"; ctx.fillRect(x,y,this.w,this.h);
    ctx.fillStyle="#000"; ctx.fillRect(x+6,y+6,4,6); ctx.fillRect(x+16,y+6,4,6);
  }
}
let enemies = spawnEnemies(100);
function spawnEnemies(n){
  const arr=[]; const gy=(ROWS-1)*TILE; const minX=TILE*12, maxX=(COLS-8)*TILE;
  const step=Math.max(40, Math.floor((maxX-minX)/n));
  for(let i=0;i<n;i++){
    const x = minX + i*step + (i%7)*6;
    const y = gy - 22;
    arr.push(new Goomba(x,y));
  }
  return arr;
}

// ============== ゲーム状態 ==============
let score=0, lives=3, paused=false, gameState='playing';

// ============== 入力 ==============
const keys={left:false,right:false,jump:false,jumpHeld:false};
addEventListener('keydown',e=>{
  unlockBGM(); // 初回キーでAudioContext再開
  if(e.repeat) return;
  if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') keys.left=true;
  if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') keys.right=true;
  if(e.key===' '||e.key==='z'||e.key==='Z'){ keys.jump=true; keys.jumpHeld=true; }
  if(e.key==='p'||e.key==='P'){ paused=!paused; gameState=paused?'paused':'playing'; UI.refresh(); }
  if(e.key==='r'||e.key==='R'){ restart(); }
});
addEventListener('keyup',e=>{
  if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') keys.left=false;
  if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') keys.right=false;
  if(e.key===' '||e.key==='z'||e.key==='Z'){ keys.jumpHeld=false; }
});
canvas.addEventListener('pointerdown', unlockBGM);

UI.pause.addEventListener('click', e=>{ e.preventDefault(); paused=!paused; gameState=paused?'paused':'playing'; UI.refresh(); });
UI.restart.addEventListener('click', e=>{ e.preventDefault(); restart(); });

// ============== BGM（Web Audioで軽量チップチューン） ==============
const bgm = {
  ctx:null, gain:null, isOn:false, heardFirstGesture:false,
  tempo: 130, // BPM
  // 簡易シーケンス（I-IV-V 進行ぽい）：C, F, G をベースに8分でループ
  seq: [
    ["C4","E4","G4","C5","E4","G4","B3","G4"],
    ["F3","A3","C4","F4","A3","C4","E4","C4"],
    ["G3","B3","D4","G4","B3","D4","F4","D4"],
    ["C4","E4","G4","C5","E4","G4","B3","G4"]
  ],
  tHandle:null, step:0, bar:0,
  noteHz(n){ // "C4" etc to Hz
    const noteMap = {C:0,"C#":1,Db:1,D:2,"D#":3,Eb:3,E:4,F:5,"F#":6,Gb:6,G:7,"G#":8,Ab:8,A:9,"A#":10,Bb:10,B:11};
    const m = n.match(/^([A-G]#?|Db|Eb|Gb|Bb)(\d)$/); if(!m) return 440;
    const semis = noteMap[m[1]] + (parseInt(m[2])-4)*12;
    return 440 * Math.pow(2,(semis-9)/12); // A4=440, A4 index=9
  },
  create(){ if(this.ctx) return;
    const ctx = new (window.AudioContext||window.webkitAudioContext)();
    const gain = ctx.createGain(); gain.gain.value = parseFloat(UI.vol.value);
    gain.connect(ctx.destination);
    this.ctx=ctx; this.gain=gain;
  },
  start(){
    this.create();
    if(this.ctx.state==="suspended") return; // ジェスチャー前
    if(this.isOn) return;
    this.isOn=true; UI.refresh();
    const beatMs = 60000/this.tempo; // 1拍
    const stepMs = beatMs/2;        // 8分
    const schedule = ()=>{
      if(!this.isOn) return;
      const now = this.ctx.currentTime;
      const notes = this.seq[this.bar % this.seq.length];
      const note = notes[this.step % notes.length];
      this.playNote(note, now, 0.25); // 16分ちょい伸ばす
      this.step++;
      if(this.step % 8 === 0) this.bar++;
    };
    schedule();
    this.tHandle = setInterval(schedule, stepMs);
  },
  stop(){
    if(!this.isOn) return;
    this.isOn=false; UI.refresh();
    if(this.tHandle) { clearInterval(this.tHandle); this.tHandle=null; }
  },
  toggle(){ if(!this.isOn){ this.start(); } else { this.stop(); } },
  playNote(note, when, length){
    const hz = this.noteHz(note);
    // 2音レイヤー（矩形+ノイズ少々）でレトロ感
    const o = this.ctx.createOscillator();
    o.type="square"; o.frequency.value=hz;
    const o2 = this.ctx.createOscillator();
    o2.type="triangle"; o2.frequency.value=hz*2;

    const g = this.ctx.createGain(); g.gain.value=0;
    o.connect(g); o2.connect(g); g.connect(this.gain);

    // ADSR（超簡易）
    const a=0.01, d=0.08, s=0.2, r=0.06;
    const v=0.18; // 音量
    g.gain.setValueAtTime(0, when);
    g.gain.linearRampToValueAtTime(v, when+a);
    g.gain.linearRampToValueAtTime(v*s, when+a+d);
    g.gain.setTargetAtTime(0, when+a+d+length, r);

    o.start(when); o.stop(when+a+d+length+0.2);
    o2.start(when); o2.stop(when+a+d+length+0.2);
  }
};
function unlockBGM(){
  if(bgm.heardFirstGesture) return;
  bgm.create();
  if(bgm.ctx.state==="suspended"){
    bgm.ctx.resume().then(()=>{ bgm.heardFirstGesture=true; }).catch(()=>{});
  } else {
    bgm.heardFirstGesture=true;
  }
}
UI.bgmBtn.addEventListener('click', e=>{ e.preventDefault(); unlockBGM(); bgm.toggle(); });
UI.vol.addEventListener('input', ()=>{ if(bgm.gain) bgm.gain.gain.value = parseFloat(UI.vol.value); });

// ページの可視状態に合わせてBGMを止める（タブ切替で静かに）
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden){ bgm.stop(); } else { if(bgm.isOn) bgm.start(); }
});

// ============== ループ ==============
function update(){
  requestAnimationFrame(update);
  if(gameState==='over'){ draw(); drawBanner("GAME OVER - Rで再スタート"); return; }
  if(gameState==='clear'){ draw(); drawBanner("GOAL!! おめでとう - Rで再スタート"); return; }
  if(paused){ draw(); drawPause(); return; }

  // 移動
  if(keys.left){ player.vx -= MOVE_A; player.facing=-1; }
  if(keys.right){ player.vx += MOVE_A; player.facing=1; }
  player.vx = Math.max(-MAX_VX, Math.min(MAX_VX, player.vx));
  if(player.onGround && !keys.left && !keys.right) player.vx *= GROUND_FRICTION;
  if(!player.onGround && !keys.left && !keys.right) player.vx *= AIR_DRAG;

  // ジャンプ
  if(keys.jump){
    if(player.onGround){ player.vy = JUMP_V; player.onGround=false; player.canDouble=true; }
    else if(player.canDouble){ player.vy = JUMP_V*0.92; player.canDouble=false; }
    keys.jump=false;
  }
  if(!keys.jumpHeld && player.vy<0) player.vy *= CUT_JUMP;

  // 重力
  player.vy += GRAV;

  // 縦
  player.y += player.vy;
  let colY = collideRectTile(player,0,player.vy);
  if(colY.collide){
    if(player.vy>0){ player.y=colY.snap; player.vy=0; player.onGround=true; }
    else { player.y=colY.snap; player.vy=0; } // 上ぶつかり
  } else { player.onGround=false; }

  // 横
  player.x += player.vx;
  let colX = collideRectTile(player,player.vx,0);
  if(colX.collide){ player.x=colX.snap; player.vx=0; }

  // 落下
  if(player.y > ROWS*TILE + 200) die();

  // 敵
  for(const e of enemies){ e.update(); }
  for(const e of enemies){
    if(!e.alive) continue;
    if(aabb(player,e)){
      const stomp = player.y + player.h <= e.y + 8 && player.vy > 0;
      if(stomp){ e.alive=false; player.vy=JUMP_V*0.6; score+=200; UI.refresh(); }
      else { die(); break; }
    }
  }

  // ゴール
  if(checkGoal()){ gameState='clear'; paused=false; }

  // カメラ
  view.x = Math.floor(player.x + player.w/2 - view.w/2);
  view.y = Math.floor(player.y + player.h/2 - view.h/2);
  view.x = Math.max(0, Math.min(COLS*TILE - view.w, view.x));
  view.y = Math.max(0, Math.min(ROWS*TILE - view.h, view.y));

  draw();
}

function aabb(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
function checkGoal(){
  const tx = Math.floor((player.x + player.w/2)/TILE);
  const ty = Math.floor((player.y + player.h/2)/TILE);
  return level[ty]?.[tx] === T.FLAG;
}
function die(){
  lives--; UI.refresh();
  if(lives<0){ gameState='over'; bgm.stop(); }
  else { player.x=TILE*2; player.y=TILE*(ROWS-4); player.vx=0; player.vy=0; player.onGround=false; view.x=0; view.y=0; }
}
function restart(){
  level = makeLevel(); enemies = spawnEnemies(100);
  score=0; lives=3; paused=false; gameState='playing';
  player.x=TILE*2; player.y=TILE*(ROWS-4); player.vx=0; player.vy=0; player.onGround=false; view.x=0; view.y=0;
  UI.refresh();
}

// ============== 描画 ==============
function draw(){
  drawSky(); drawMountains(); drawHills();
  // タイル（画面内のみ）
  const c0=Math.max(0, Math.floor(view.x/TILE)-1),
        c1=Math.min(COLS-1, Math.floor((view.x+view.w)/TILE)+1),
        r0=Math.max(0, Math.floor(view.y/TILE)-1),
        r1=Math.min(ROWS-1, Math.floor((view.y+view.h)/TILE)+1);
  for(let r=r0;r<=r1;r++){
    for(let c=c0;c<=c1;c++){
      const t=level[r][c]; if(t===T.EMPTY) continue;
      const x=c*TILE - view.x, y=r*TILE - view.y;
      if(t===T.GROUND){
        ctx.fillStyle="#3a5f0b"; ctx.fillRect(x,y,TILE,TILE);
        ctx.fillStyle="#2b4510"; ctx.fillRect(x,y+14,TILE,TILE-14);
      }else if(t===T.BLOCK){
        ctx.fillStyle="#b87333"; ctx.fillRect(x,y,TILE,TILE);
        ctx.strokeStyle="#7a4e20"; ctx.strokeRect(x+0.5,y+0.5,TILE-1,TILE-1);
      }else if(t===T.FLAG){
        ctx.fillStyle="#888"; ctx.fillRect(x+14,y,4,TILE*2);
        ctx.fillStyle="#58a6ff"; ctx.beginPath(); ctx.moveTo(x+18,y+6); ctx.lineTo(x+48,y+14); ctx.lineTo(x+18,y+22); ctx.closePath(); ctx.fill();
      }
    }
  }
  // 敵
  for(const e of enemies){ e.draw(); }
  // プレイヤー
  const px=Math.floor(player.x-view.x), py=Math.floor(player.y-view.y);
  ctx.fillStyle="#ff6b6b"; ctx.fillRect(px,py,player.w,player.h);
  ctx.fillStyle="#000"; ctx.fillRect(px+(player.facing>=0?14:4), py+6, 4,6);
}
function drawSky(){ const g=ctx.createLinearGradient(0,0,0,view.h); g.addColorStop(0,"#0a1220"); g.addColorStop(1,"#0a0f14"); ctx.fillStyle=g; ctx.fillRect(0,0,view.w,view.h); }
function drawMountains(){ ctx.save(); ctx.translate(-view.x*0.3,-view.y*0.1); ctx.fillStyle="#101a2b";
  for(let i=0;i<10;i++){ const xx=i*300-100; ctx.beginPath(); ctx.moveTo(xx,view.h); ctx.lineTo(xx+120,view.h-150); ctx.lineTo(xx+240,view.h); ctx.closePath(); ctx.fill(); }
  ctx.restore(); }
function drawHills(){ ctx.save(); ctx.translate(-view.x*0.6,0); ctx.fillStyle="#0f1d2e";
  for(let i=0;i<14;i++){ const xx=i*180-60; ctx.beginPath(); ctx.ellipse(xx,view.h-20,120,30,0,0,Math.PI*2); ctx.fill(); }
  ctx.restore(); }
function drawBanner(text){
  ctx.fillStyle="rgba(0,0,0,.55)"; ctx.fillRect(0,0,view.w,view.h);
  ctx.fillStyle="#fff"; ctx.textAlign="center"; ctx.font="bold 26px system-ui";
  ctx.fillText(text, view.w/2, view.h/2);
}
function drawPause(){ drawBanner("一時停止中 - Pで再開"); }

// ============== 起動 ==============
function boot(){ fitCanvas(); UI.refresh(); requestAnimationFrame(update); }
boot();

})();
</script>
</body>
</html>
