<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>ブロック崩し</title>
<style>
  :root{--bg:#0d1117;--fg:#e6edf3;--mut:#8b949e;--acc:#58a6ff}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif}
  .wrap{max-width:820px;margin:16px auto;padding:0 12px;text-align:center}
  h1{font-size:clamp(18px,2.2vw,22px);margin:6px 0 10px}
  #game{display:block;margin:0 auto;background:#0a0f14;border:1px solid #30363d;border-radius:10px;touch-action:none}
  .hud{display:flex;gap:16px;justify-content:center;align-items:center;margin:10px 0 14px;color:var(--mut);font-size:14px}
  .hud strong{color:var(--fg)}
  .btn{display:inline-block;padding:8px 14px;border:1px solid #30363d;border-radius:8px;color:var(--fg);text-decoration:none}
  .btn:hover{background:#161b22}
  .tips{color:var(--mut);font-size:13px}
</style>
</head>
<body>
<div class="wrap">
  <h1>ブロック崩し</h1>
  <canvas id="game" aria-label="game canvas"></canvas>
  <div class="hud">
    <div>スコア：<strong id="score">0</strong></div>
    <div>残機：<strong id="lives">3</strong></div>
    <div>レベル：<strong id="level">1</strong></div>
    <a href="#" id="pauseBtn" class="btn">⏸ 一時停止(P)</a>
    <a href="#" id="restartBtn" class="btn">↺ リスタート(R)</a>
  </div>
  <div class="tips">← → または マウス/スワイプで移動 · Pで一時停止 · Rでリスタート</div>
</div>

<script>
(()=>{
// ===== 基本セットアップ =====
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', {alpha:false});
const ui = {
  score: document.getElementById('score'),
  lives: document.getElementById('lives'),
  level: document.getElementById('level'),
  pauseBtn: document.getElementById('pauseBtn'),
  restartBtn: document.getElementById('restartBtn'),
  refresh(){ this.score.textContent=score; this.lives.textContent=lives; this.level.textContent=level;
             this.pauseBtn.textContent = paused ? "▶ 再開(P)" : "⏸ 一時停止(P)"; }
};

// 画面サイズにフィット（高DPIもクッキリ）
const sizes = {
  cw:640, ch:840,
  brick:{rows:5, cols:8, w:0, h:20, pad:4, top:60, left:8},
  paddleW:96, paddleH:12, paddleY:0,
  recalc(cssW, cssH){
    this.cw=cssW; this.ch=cssH;
    // パドル・ブロックは画面に収まる比率で算出
    this.paddleW = Math.max(48, Math.floor(cssW*0.15)); // 画面幅の15%
    this.paddleH = Math.max(8, Math.floor(cssH*0.014));
    this.paddleY = cssH - Math.floor(cssH*0.09);

    this.brick.cols = 8;
    this.brick.rows = 5 + (level-1);                      // レベルで段数UP
    const totalPad = (this.brick.cols+1)*this.brick.pad + 16;
    this.brick.w = Math.max(20, Math.floor((cssW - totalPad)/this.brick.cols));
    this.brick.h = Math.max(14, Math.floor(cssH*0.024));
    this.brick.left = 8;
    this.brick.top  = Math.floor(cssH*0.08);
  }
};

function fitCanvas(){
  const cssW = Math.min(820, Math.floor(window.innerWidth - 24)); // 余白を引いて収める
  const cssH = Math.floor(cssW * 1.25);                            // 縦横比
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  canvas.style.width  = cssW + 'px';
  canvas.style.height = cssH + 'px';
  canvas.width  = cssW * dpr;
  canvas.height = cssH * dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0); // スケール設定
  sizes.recalc(cssW, cssH);
}

// ===== ゲーム状態 =====
let score=0, lives=3, level=1, paused=false, running=true;
const paddle = {x:0, speed:0, maxSpeed:9};
const ball   = {x:0, y:0, r:7, vx:0, vy:0, speedBase:6};
let bricks = [];

// ===== 初期化 =====
function buildBricks(){
  bricks = [];
  const R = sizes.brick.rows, C = sizes.brick.cols;
  for(let r=0;r<R;r++){
    bricks[r]=[];
    for(let c=0;c<C;c++){
      bricks[r][c]={alive:true, color:`hsl(${(200+r*12)%360} 70% 55%)`};
    }
  }
}
function resetBall(center=true){
  paddle.x = (sizes.cw - sizes.paddleW)/2;
  ball.r = Math.max(6, Math.floor(sizes.ch*0.008));
  ball.x = sizes.cw/2;
  ball.y = sizes.ch*0.62;
  const sp = ball.speedBase*(1+(level-1)*0.1);
  const ang = (-Math.PI/3) - Math.random()*Math.PI/6; // 上向き
  ball.vx = sp*Math.cos(ang);
  ball.vy = sp*Math.sin(ang);
  if(center) paddle.x = (sizes.cw - sizes.paddleW)/2;
}
function init(){
  fitCanvas(); buildBricks(); resetBall(true); ui.refresh(); requestAnimationFrame(update);
}
window.addEventListener('resize', ()=>{fitCanvas();});

// ===== 入力 =====
const keys={left:false,right:false};
addEventListener('keydown',e=>{
  if(e.key==='ArrowLeft') keys.left=true;
  if(e.key==='ArrowRight') keys.right=true;
  if(e.key==='p'||e.key==='P'){ paused=!paused; ui.refresh(); }
  if(e.key==='r'||e.key==='R'){ startOver(); }
});
addEventListener('keyup',e=>{
  if(e.key==='ArrowLeft') keys.left=false;
  if(e.key==='ArrowRight') keys.right=false;
});
const moveTo = clientX=>{
  const rect=canvas.getBoundingClientRect();
  const x=clientX-rect.left;
  paddle.x = Math.max(0, Math.min(sizes.cw - sizes.paddleW, x - sizes.paddleW/2));
};
canvas.addEventListener('mousemove',e=>moveTo(e.clientX));
canvas.addEventListener('touchmove',e=>{if(e.touches[0]) moveTo(e.touches[0].clientX); e.preventDefault();},{passive:false});
ui.pauseBtn.addEventListener('click',e=>{e.preventDefault(); paused=!paused; ui.refresh();});
ui.restartBtn.addEventListener('click',e=>{e.preventDefault(); startOver();});

// ===== ループ =====
function update(){
  if(!running) return;
  requestAnimationFrame(update);
  if(paused) return draw();

  // パドル
  if(keys.left)  paddle.x = Math.max(0, paddle.x - paddle.maxSpeed);
  if(keys.right) paddle.x = Math.min(sizes.cw - sizes.paddleW, paddle.x + paddle.maxSpeed);

  // ボール
  ball.x += ball.vx; ball.y += ball.vy;

  // 壁
  if(ball.x - ball.r < 0){ ball.x = ball.r; ball.vx *= -1; }
  if(ball.x + ball.r > sizes.cw){ ball.x = sizes.cw - ball.r; ball.vx *= -1; }
  if(ball.y - ball.r < 0){ ball.y = ball.r; ball.vy *= -1; }

  // パドル衝突（反射角調整）
  if(ball.y + ball.r >= sizes.paddleY && ball.y + ball.r <= sizes.paddleY + sizes.paddleH &&
     ball.x >= paddle.x && ball.x <= paddle.x + sizes.paddleW && ball.vy > 0){
    const pos = (ball.x - (paddle.x + sizes.paddleW/2))/(sizes.paddleW/2);
    const maxA = Math.PI*70/180;
    const ang = pos*maxA;
    const sp = Math.min(12, Math.hypot(ball.vx,ball.vy)*1.02);
    ball.vx = sp*Math.sin(ang);
    ball.vy = -Math.abs(sp*Math.cos(ang));
    ball.y = sizes.paddleY - ball.r - 0.1;
  }

  // ブロック衝突
  collideBricks();

  // 落下
  if(ball.y - ball.r > sizes.ch){
    if(--lives<=0){ gameOver(); } else { ui.refresh(); resetBall(); }
  }

  draw();
}

function collideBricks(){
  const {w,h,pad,top,left} = sizes.brick;
  for(let r=0;r<bricks.length;r++){
    for(let c=0;c<bricks[r].length;c++){
      const b=bricks[r][c]; if(!b.alive) continue;
      const bx = left + c*(w+pad) + pad;
      const by = top  + r*(h+pad) + pad;
      // 円 vs AABB
      const cx = Math.max(bx, Math.min(ball.x, bx+w));
      const cy = Math.max(by, Math.min(ball.y, by+h));
      const dx = ball.x - cx, dy = ball.y - cy;
      if(dx*dx + dy*dy <= ball.r*ball.r){
        b.alive=false; score+=10; ui.refresh();
        // 反射軸
        const ox = Math.min(Math.abs(ball.x - bx), Math.abs(ball.x - (bx+w)));
        const oy = Math.min(Math.abs(ball.y - by), Math.abs(ball.y - (by+h)));
        if(ox < oy) ball.vx *= -1; else ball.vy *= -1;
        // クリア
        if(isCleared()){ level++; lives=Math.min(5,lives+1); ui.refresh(); buildBricks(); resetBall(true); }
        return;
      }
    }
  }
}
function isCleared(){ for(const row of bricks) for(const b of row) if(b.alive) return false; return true; }

function draw(){
  // 背景
  ctx.fillStyle="#0a0f14"; ctx.fillRect(0,0,sizes.cw,sizes.ch);

  // ブロック
  const {w,h,pad,top,left} = sizes.brick;
  for(let r=0;r<bricks.length;r++){
    for(let c=0;c<bricks[r].length;c++){
      const b=bricks[r][c]; if(!b.alive) continue;
      const x = left + c*(w+pad) + pad;
      const y = top  + r*(h+pad) + pad;
      ctx.fillStyle=b.color; roundRect(x,y,w,h,6);
    }
  }
  // パドル
  ctx.fillStyle="#58a6ff"; roundRect(paddle.x, sizes.paddleY, sizes.paddleW, sizes.paddleH, 8);
  // ボール
  ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.closePath(); ctx.fillStyle="#e6edf3"; ctx.fill();

  if(paused){
    ctx.fillStyle="rgba(0,0,0,.4)"; ctx.fillRect(0,0,sizes.cw,sizes.ch);
    ctx.fillStyle="#fff"; ctx.textAlign="center"; ctx.font="bold 26px system-ui";
    ctx.fillText("一時停止中 - Pで再開", sizes.cw/2, sizes.ch/2);
  }
}

function roundRect(x,y,w,h,r){
  const rr=Math.min(r,w/2,h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath(); ctx.fill();
}

function gameOver(){
  running=false; draw();
  ctx.fillStyle="rgba(0,0,0,.55)"; ctx.fillRect(0,0,sizes.cw,sizes.ch);
  ctx.fillStyle="#fff"; ctx.textAlign="center"; ctx.font="bold 32px system-ui";
  ctx.fillText("GAME OVER", sizes.cw/2, sizes.ch/2-10);
  ctx.font="16px system-ui"; ctx.fillText("Rでリスタート", sizes.cw/2, sizes.ch/2+18);
}
function startOver(){ score=0; lives=3; level=1; running=true; paused=false; fitCanvas(); buildBricks(); resetBall(true); ui.refresh(); requestAnimationFrame(update); }

// 起動
init();
})();
</script>
</body>
</html>
