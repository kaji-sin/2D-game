<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« ãƒãƒªã‚ªé¢¨ï¼ˆ?ãƒ–ãƒ­ãƒƒã‚¯/ã‚¹ã‚¿ãƒ¼/ãƒ€ãƒƒã‚·ãƒ¥/ã‚¿ã‚¤ãƒˆãƒ«ï¼‰</title>
<style>
  :root { --bg:#0d1117; --fg:#e6edf3; --mut:#8b949e; --acc:#58a6ff; }
  html,body { height:100%; margin:0; background:var(--bg); color:var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; }
  .wrap { max-width: 960px; margin: 8px auto; padding: 0 12px; text-align:center; }
  h1 { font-size: clamp(18px, 2.4vw, 22px); margin: 8px 0 10px; }
  #game { display:block; margin: 0 auto; background:#0a0f14; border:1px solid #30363d; border-radius:12px; touch-action:none }
  .hud { display:flex; gap:16px; justify-content:center; align-items:center; margin:10px 0 14px; color:var(--mut); font-size:14px; flex-wrap:wrap }
  .hud strong { color: var(--fg); }
  .btn { display:inline-block; padding:6px 12px; border:1px solid #30363d; border-radius:8px; color:var(--fg); text-decoration:none }
  .btn:hover { background:#161b22; }
  .tips { color:var(--mut); font-size:13px; }
  /* ãƒ¢ãƒã‚¤ãƒ«æ“ä½œãƒœã‚¿ãƒ³ */
  .touchpad { position:fixed; left:0; right:0; bottom:14px; display:flex; justify-content:space-between; gap:12px; padding:0 12px; pointer-events:none; }
  .touchbtn { pointer-events:auto; user-select:none; -webkit-user-select:none;
    min-width:92px; min-height:92px; border:1px solid #30363d; border-radius:18px; background:#11182288; display:flex; align-items:center; justify-content:center; font-weight:700; }
  .touchbtn:active { background:#1a223088; }
  @media (min-width: 900px) { .touchpad { display:none; } } /* PCã§ã¯éè¡¨ç¤º */
</style>
</head>
<body>
<div class="wrap">
  <h1>æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒ»ãƒãƒªã‚ªé¢¨ï¼ˆæ‹¡å¼µï¼‰</h1>
  <canvas id="game" width="800" height="480" aria-label="Game canvas"></canvas>
  <div class="hud">
    <div>WORLDï¼š<strong id="world">1-1</strong></div>
    <div>ã‚¹ã‚³ã‚¢ï¼š<strong id="score">0</strong></div>
    <div>æ®‹æ©Ÿï¼š<strong id="lives">3</strong></div>
    <a href="#" id="restart" class="btn">â†º ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ(R)</a>
    <a href="#" id="pause" class="btn">â¸ ä¸€æ™‚åœæ­¢(P)</a>
  </div>
  <div class="tips">æ“ä½œï¼šâ†/â†’ or A/D ã§ç§»å‹•ãƒ»ã‚¹ãƒšãƒ¼ã‚¹/Zã§ã‚¸ãƒ£ãƒ³ãƒ—ï¼ˆç©ºä¸­1å›ï¼‰ãƒ»**Shift / X ã§ãƒ€ãƒƒã‚·ãƒ¥**ãƒ»?ãƒ–ãƒ­ãƒƒã‚¯ã§ã‚³ã‚¤ãƒ³/ã‚¹ã‚¿ãƒ¼</div>
</div>

<!-- ãƒ¢ãƒã‚¤ãƒ«ç”¨ã‚¿ãƒƒãƒæ“ä½œ -->
<div class="touchpad">
  <div style="display:flex; gap:12px;">
    <div class="touchbtn" id="btnLeft">â†</div>
    <div class="touchbtn" id="btnRight">â†’</div>
  </div>
  <div style="display:flex; gap:12px;">
    <div class="touchbtn" id="btnDash">Dash</div>
    <div class="touchbtn" id="btnJump">â¤´ï¸</div>
  </div>
</div>

<script>
(() => {
/* =========================
   ç”»åƒã‚¹ãƒ—ãƒ©ã‚¤ãƒˆï¼ˆdata URIï¼‰
   ========================= */
const SPRITES = {
  enabled: true,
  player: new Image(),
  goomba: new Image(),
  coin:   new Image(),
  star:   new Image(),
};
// ã‚·ãƒ³ãƒ—ãƒ«SVGï¼ˆå¿…è¦ãªã‚‰å¤–éƒ¨PNGã®URLã«å·®ã—æ›¿ãˆOKï¼‰
SPRITES.player.src =
'data:image/svg+xml;utf8,' + encodeURIComponent(`
<svg xmlns="http://www.w3.org/2000/svg" width="22" height="28">
  <rect width="22" height="28" rx="4" ry="4" fill="#ff6b6b"/>
  <rect x="14" y="6" width="4" height="6" fill="#000"/>
</svg>`);
SPRITES.goomba.src =
'data:image/svg+xml;utf8,' + encodeURIComponent(`
<svg xmlns="http://www.w3.org/2000/svg" width="26" height="22">
  <rect width="26" height="22" rx="4" ry="4" fill="#8B4513"/>
  <rect x="6" y="6" width="4" height="6" fill="#000"/>
  <rect x="16" y="6" width="4" height="6" fill="#000"/>
</svg>`);
SPRITES.coin.src =
'data:image/svg+xml;utf8,' + encodeURIComponent(`
<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18">
  <circle cx="9" cy="9" r="8" fill="#ffd54a" stroke="#e0b935" stroke-width="2"/>
</svg>`);
SPRITES.star.src =
'data:image/svg+xml;utf8,' + encodeURIComponent(`
<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22">
  <polygon points="11,1 14,8 22,8 16,12 18,20 11,15 4,20 6,12 0,8 8,8" fill="#ffe066" stroke="#e6c14a" stroke-width="1"/>
</svg>`);

/* =========================
   åŸºæœ¬ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
   ========================= */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha:false });
const UI = {
  world: document.getElementById('world'),
  score: document.getElementById('score'),
  lives: document.getElementById('lives'),
  pause: document.getElementById('pause'),
  restart: document.getElementById('restart'),
  refresh(){ this.world.textContent = `1-${levelIndex+1}`;
             this.score.textContent = score; this.lives.textContent = lives;
             this.pause.textContent = paused ? "â–¶ å†é–‹(P)" : "â¸ ä¸€æ™‚åœæ­¢(P)"; }
};

// ç”»é¢ãƒ•ã‚£ãƒƒãƒˆï¼ˆå¹…ãƒ»é«˜ã•ã®ä¸¡æ–¹ã‚’æº€ãŸã™ï¼‰
function fitCanvas(){
  const marginY = 180;         // ã‚¿ã‚¤ãƒˆãƒ«ãƒ»HUDã¶ã‚“
  const AR = 480/800;          // æ—¢å®šæ¯”ç‡
  const maxW = Math.min(960, window.innerWidth - 24);
  const maxH = Math.max(320, window.innerHeight - marginY);
  let cssW = Math.min(maxW, Math.floor(maxH / AR));
  let cssH = Math.floor(cssW * AR);
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  canvas.width  = cssW * dpr;
  canvas.height = cssH * dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  view.w = cssW; view.h = cssH;
}
addEventListener('resize', fitCanvas);

/* =========================
   ã‚¿ã‚¤ãƒ« & ãƒ¬ãƒ™ãƒ«
   ========================= */
const TILE = 32;
const T = { EMPTY:0, GROUND:1, BLOCK:2, COIN:3, FLAG:4, QBLOCK:5, USED:6 };

const LEVELS = [
  [
    "................................................................",
    "....................3....................5......................",
    "............................222....................222..........",
    "...................3.....................3......................",
    ".............222....................222...............5.........",
    "............................................................4...",
    "..............................................222...............",
    ".........................3......................................",
    "..............222..................222..........................",
    "................................................................",
    "................................................................",
    "#############################################..##################",
  ],
  [
    "................................................................",
    ".................................................5..............",
    "....................2222......................2222..............",
    "..............3.................................................",
    "............................................................4...",
    "..............2222.....................2222.....................",
    ".........................5......................................",
    ".................................................3..............",
    "................................................................",
    ".........222.................222.................................",
    "................................................................",
    "#############################################..##################",
  ],
].map(rows => rows.map(row => row.split("").map(ch =>
  ch==="#"?T.GROUND: ch==="."?T.EMPTY: ch==="2"?T.BLOCK: ch==="3"?T.COIN: ch==="4"?T.FLAG: ch==="5"?T.QBLOCK:T.EMPTY
)));

let levelIndex=0, level=LEVELS[0];

/* =========================
   ç‰©ç†ãƒ»ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ»æ•µ
   ========================= */
let GRAV=0.72, JUMP_V=-12.0, MOVE_A=0.9, MAX_VX=5.4;
const DASH_A=1.2, DASH_MAX=7.2;
const AIR_DRAG=0.93, GROUND_FRICTION=0.86, CUT_JUMP=0.5;

const view = { x:0, y:0, w:800, h:480 };

const playerBase = { w:22, h:28 };
const player = { x:TILE*2, y:TILE*8, w:playerBase.w, h:playerBase.h,
  vx:0, vy:0, onGround:false, canDouble:false, facing:1,
  starTimer:0, // ç„¡æ•µä¸­>0
};

class Goomba{
  constructor(x,y){ this.x=x; this.y=y; this.w=26; this.h=22; this.vx=-1; this.alive=true; }
  update(){
    if(!this.alive) return;
    this.vy=(this.vy??0)+GRAV; this.y+=this.vy;
    const hy=collideRectTile(this,0,this.vy); if(hy.collide && this.vy>0){ this.y=hy.snap; this.vy=0; }
    this.x+=this.vx;
    const hx=collideRectTile(this,this.vx,0); if(hx.collide){ this.x=hx.snap; this.vx*=-1; }
    if(this.y>levelH()+200) this.alive=false;
  }
  draw(){
    if(!this.alive) return;
    const x=Math.floor(this.x-view.x), y=Math.floor(this.y-view.y);
    if(SPRITES.enabled && SPRITES.goomba.complete){ ctx.drawImage(SPRITES.goomba,x,y); }
    else{ ctx.fillStyle="#8B4513"; ctx.fillRect(x,y,this.w,this.h); }
  }
}
let enemies=[];

/* ===== ã‚¢ã‚¤ãƒ†ãƒ  ===== */
class Star{
  constructor(x,y){ this.x=x; this.y=y; this.w=22; this.h=22; this.vx=1.4; this.vy=-5; this.alive=true; }
  update(){
    if(!this.alive) return;
    this.vy+=GRAV; this.y+=this.vy; let hy=collideRectTile(this,0,this.vy);
    if(hy.collide){ if(this.vy>0){ this.y=hy.snap; this.vy=-10; } else { this.y=hy.snap; this.vy=0; } } // ãƒ”ãƒ§ãƒ³ãƒ”ãƒ§ãƒ³
    this.x+=this.vx; let hx=collideRectTile(this,this.vx,0); if(hx.collide){ this.x=hx.snap; this.vx*=-1; }
    if(aabb(this,player)){ this.alive=false; player.starTimer=8*60; } // 8ç§’ç„¡æ•µ
  }
  draw(){
    if(!this.alive) return; const x=Math.floor(this.x-view.x), y=Math.floor(this.y-view.y);
    if(SPRITES.enabled && SPRITES.star.complete){ ctx.drawImage(SPRITES.star,x,y); }
    else{ ctx.fillStyle="#ffe066"; ctx.fillRect(x,y,this.w,this.h); }
  }
}
class CoinPop{
  constructor(x,y){ this.x=x; this.y=y; this.t=30; this.score=200; }
  update(){ this.y-=1.8; this.t--; if(this.t<=0) this.dead=true; }
  draw(){ const x=Math.floor(this.x-view.x), y=Math.floor(this.y-view.y);
    if(SPRITES.enabled && SPRITES.coin.complete){ ctx.drawImage(SPRITES.coin,x,y); }
    else{ ctx.fillStyle="#ffd54a"; ctx.beginPath(); ctx.arc(x+9,y+9,8,0,Math.PI*2); ctx.fill(); }
  }
}
let items=[]; // Star, CoinPop ãªã©

/* =========================
   çŠ¶æ…‹
   ========================= */
let score=0, lives=3, paused=false, gameState='title'; // title / playing / paused / over / clear

/* =========================
   ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
   ========================= */
function rows(){ return level.length; }
function cols(){ return level[0].length; }
function levelW(){ return cols()*TILE; }
function levelH(){ return rows()*TILE; }

function aabb(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

function tileAt(px,py){
  if(px<0||py<0||px>=levelW()||py>=levelH()) return T.GROUND;
  const c=Math.floor(px/TILE), r=Math.floor(py/TILE);
  return level[r][c];
}
function collideRectTile(rect,dx,dy){
  const nx=rect.x, ny=rect.y;
  if(dx>0){
    const x=nx+rect.w, top=Math.floor((ny+1)/TILE), bottom=Math.floor((ny+rect.h-1)/TILE);
    for(let r=top;r<=bottom;r++){ const t=level[r]?.[Math.floor(x/TILE)];
      if(t===T.GROUND||t===T.BLOCK||t===T.USED||t===T.QBLOCK){ return {collide:true, snap:Math.floor((x)/TILE)*TILE-rect.w, r, c:Math.floor(x/TILE)}; }
    }
  } else if(dx<0){
    const x=nx, top=Math.floor((ny+1)/TILE), bottom=Math.floor((ny+rect.h-1)/TILE);
    for(let r=top;r<=bottom;r++){ const t=level[r]?.[Math.floor((x-1)/TILE)];
      if(t===T.GROUND||t===T.BLOCK||t===T.USED||t===T.QBLOCK){ return {collide:true, snap:Math.floor((x-1)/TILE+1)*TILE, r, c:Math.floor((x-1)/TILE)}; }
    }
  }
  if(dy>0){
    const y=ny+rect.h, left=Math.floor((nx+3)/TILE), right=Math.floor((nx+rect.w-3)/TILE);
    for(let c=left;c<=right;c++){ const t=level[Math.floor(y/TILE)]?.[c];
      if(t===T.GROUND||t===T.BLOCK||t===T.USED||t===T.QBLOCK){ return {collide:true, snap:Math.floor(y/TILE)*TILE-rect.h, r:Math.floor(y/TILE), c}; }
    }
  } else if(dy<0){
    const y=ny, left=Math.floor((nx+3)/TILE), right=Math.floor((nx+rect.w-3)/TILE);
    for(let c=left;c<=right;c++){ const r=Math.floor((y-1)/TILE); const t=level[r]?.[c];
      if(t===T.GROUND||t===T.BLOCK||t===T.USED||t===T.QBLOCK){ return {collide:true, snap:Math.floor((y-1)/TILE+1)*TILE, r, c}; }
    }
  }
  return {collide:false, snap:0};
}

/* =========================
   ï¼Ÿãƒ–ãƒ­ãƒƒã‚¯å‡¦ç†
   ========================= */
function hitQBlock(r,c){
  if(level[r][c]!==T.QBLOCK) return;
  level[r][c]=T.USED;
  const chance=Math.random();
  if(chance<0.7){
    // ã‚³ã‚¤ãƒ³ï¼šã‚¹ã‚³ã‚¢åŠ ç®—ï¼†ãƒãƒƒãƒ—æ¼”å‡º
    score+=200; UI.refresh();
    items.push(new CoinPop(c*TILE+7, r*TILE-12));
  }else{
    // ã‚¹ã‚¿ãƒ¼ç”Ÿæˆ
    items.push(new Star(c*TILE+5, r*TILE-22));
  }
}

/* =========================
   å…¥åŠ›
   ========================= */
const keys={left:false,right:false,jump:false,jumpHeld:false,dash:false};
addEventListener('keydown',e=>{
  if(gameState==='title'){ if(e.key==='Enter'){ startGame(); } return; }
  if(e.repeat) return;
  if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') keys.left=true;
  if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') keys.right=true;
  if(e.key===' '||e.key==='z'||e.key==='Z'){ keys.jump=true; keys.jumpHeld=true; }
  if(e.key==='Shift'||e.key==='x'||e.key==='X'){ keys.dash=true; }
  if(e.key==='p'||e.key==='P'){ paused=!paused; gameState=paused?'paused':'playing'; UI.refresh(); }
  if(e.key==='r'||e.key==='R'){ restartLevel(); }
});
addEventListener('keyup',e=>{
  if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') keys.left=false;
  if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') keys.right=false;
  if(e.key===' '||e.key==='z'||e.key==='Z'){ keys.jumpHeld=false; }
  if(e.key==='Shift'||e.key==='x'||e.key==='X'){ keys.dash=false; }
});
canvas.addEventListener('click', ()=>{ if(gameState==='title') startGame(); });

// ãƒ¢ãƒã‚¤ãƒ«ãƒœã‚¿ãƒ³
const bindHold=(el,on,off)=>{ const start=ev=>{ev.preventDefault();on();}; const end=ev=>{ev.preventDefault();off();};
  el.addEventListener('touchstart',start,{passive:false}); el.addEventListener('touchend',end,{passive:false});
  el.addEventListener('touchcancel',end,{passive:false}); el.addEventListener('mousedown',start);
  el.addEventListener('mouseup',end); el.addEventListener('mouseleave',end);
};
bindHold(document.getElementById('btnLeft'), ()=>keys.left=true, ()=>keys.left=false);
bindHold(document.getElementById('btnRight'),()=>keys.right=true,()=>keys.right=false);
bindHold(document.getElementById('btnJump'), ()=>{ keys.jump=true; keys.jumpHeld=true; }, ()=>keys.jumpHeld=false);
bindHold(document.getElementById('btnDash'), ()=>keys.dash=true, ()=>keys.dash=false);

UI.pause.addEventListener('click', e=>{ e.preventDefault(); if(gameState==='title') return; paused=!paused; gameState=paused?'paused':'playing'; UI.refresh(); });
UI.restart.addEventListener('click', e=>{ e.preventDefault(); if(gameState==='title') return; restartLevel(); });

/* =========================
   æ›´æ–°
   ========================= */
function update(){
  requestAnimationFrame(update);
  if(gameState==='title'){ drawTitle(); return; }
  if(gameState==='over'){ drawBanner("GAME OVER - Enter ã§ã‚¿ã‚¤ãƒˆãƒ«ã¸"); return; }
  if(gameState==='clear'){ drawBanner("ALL CLEAR! ğŸ‰ Enter ã§ã‚¿ã‚¤ãƒˆãƒ«ã¸"); return; }
  if(paused){ drawPause(); return; }

  // ãƒ€ãƒƒã‚·ãƒ¥ä¿‚æ•°
  const curA = keys.dash ? DASH_A : MOVE_A;
  const curMax = keys.dash ? DASH_MAX : MAX_VX;

  // æ¨ªç§»å‹•
  if(keys.left){ player.vx -= curA; player.facing=-1; }
  if(keys.right){ player.vx += curA; player.facing=1; }
  player.vx = Math.max(-curMax, Math.min(curMax, player.vx));
  if(player.onGround && !keys.left && !keys.right) player.vx *= GROUND_FRICTION;
  if(!player.onGround && !keys.left && !keys.right) player.vx *= AIR_DRAG;

  // ã‚¸ãƒ£ãƒ³ãƒ—ï¼ˆå¯å¤‰ï¼‰
  if(keys.jump){
    if(player.onGround){ player.vy = JUMP_V; player.onGround=false; player.canDouble=true; }
    else if(player.canDouble){ player.vy = JUMP_V*0.92; player.canDouble=false; }
    keys.jump=false;
  }
  if(!keys.jumpHeld && player.vy<0) player.vy *= CUT_JUMP;

  // é‡åŠ›
  player.vy += GRAV;

  // ç¸¦
  player.y += player.vy;
  const colY=collideRectTile(player,0,player.vy);
  if(colY.collide){
    if(player.vy>0){ player.y=colY.snap; player.vy=0; player.onGround=true; }
    else{ player.y=colY.snap; player.vy=0; // é ­ã¶ã¤ã‘
      if(colY.r!=null && colY.c!=null && level[colY.r][colY.c]===T.QBLOCK){ hitQBlock(colY.r,colY.c); }
    }
  }else{ player.onGround=false; }

  // æ¨ª
  player.x += player.vx;
  const colX=collideRectTile(player,player.vx,0);
  if(colX.collide){ player.x=colX.snap; player.vx=0; }

  // è½ä¸‹
  if(player.y > levelH()+200){ die(); }

  // æ•µãƒ»ã‚¢ã‚¤ãƒ†ãƒ 
  for(const e of enemies){ e.update(); }
  for(const it of items){ it.update?.(); }
  items = items.filter(it => !it.dead && (it.alive===undefined || it.alive));

  // å½“ãŸã‚Šï¼šæ•µ
  for(const e of enemies){
    if(!e.alive) continue;
    if(aabb(player,e)){
      const stomp = player.y + player.h <= e.y + 8 && player.vy > 0;
      if(player.starTimer>0 || stomp){
        e.alive=false; if(stomp){ player.vy=JUMP_V*0.6; } score+=200; UI.refresh();
      }else{
        die(); break;
      }
    }
  }

  // ã‚´ãƒ¼ãƒ«
  const under = tileAt(player.x+player.w/2, player.y+player.h/2);
  if(under===T.FLAG){ nextLevel(); }

  // ã‚«ãƒ¡ãƒ©
  view.x = Math.floor(player.x + player.w/2 - view.w/2);
  view.y = Math.floor(player.y + player.h/2 - view.h/2);
  view.x = Math.max(0, Math.min(levelW()-view.w, view.x));
  view.y = Math.max(0, Math.min(levelH()-view.h, view.y));

  // ã‚¹ã‚¿ãƒ¼æ™‚é–“
  if(player.starTimer>0) player.starTimer--;

  draw();
}

/* =========================
   ãƒ¬ãƒ™ãƒ«ãƒ»ãƒ©ã‚¤ãƒ•
   ========================= */
function loadLevel(idx){
  levelIndex=idx; level=LEVELS[idx].map(row=>row.slice());
  enemies=[
    new Goomba(32*20, 32*9-22),
    new Goomba(32*35, 32*9-22),
    new Goomba(32*50, 32*9-22)
  ];
  items=[]; respawn();
}
function nextLevel(){
  if(levelIndex+1 >= LEVELS.length){ gameState='clear'; paused=false; return; }
  loadLevel(levelIndex+1); UI.refresh();
}
function die(){
  lives--; UI.refresh();
  if(lives<0){ gameState='over'; }
  else { respawn(); }
}
function respawn(){
  player.x=TILE*2; player.y=TILE*8; player.vx=0; player.vy=0; player.onGround=false; player.starTimer=0;
  view.x=0; view.y=0;
}
function restartLevel(){
  lives=3; score=0; loadLevel(levelIndex); paused=false; gameState='playing'; UI.refresh();
}

/* =========================
   æç”»
   ========================= */
function draw(){
  // èƒŒæ™¯
  drawSky(); drawMountains(); drawHills();

  // ã‚¿ã‚¤ãƒ«
  for(let r=0;r<rows();r++){
    for(let c=0;c<cols();c++){
      const t=level[r][c]; if(t===T.EMPTY) continue;
      const x=c*TILE-view.x, y=r*TILE-view.y;
      if(x+TILE<0||x>view.w||y+TILE<0||y>view.h) continue;
      switch(t){
        case T.GROUND:
          ctx.fillStyle="#3a5f0b"; ctx.fillRect(x,y,TILE,TILE);
          ctx.fillStyle="#2b4510"; ctx.fillRect(x,y+14,TILE,TILE-14); break;
        case T.BLOCK:
          ctx.fillStyle="#b87333"; ctx.fillRect(x,y,TILE,TILE);
          ctx.strokeStyle="#7a4e20"; ctx.strokeRect(x+0.5,y+0.5,TILE-1,TILE-1); break;
        case T.COIN:
          if(SPRITES.enabled && SPRITES.coin.complete){ ctx.drawImage(SPRITES.coin,x+7,y+7); }
          else{ ctx.fillStyle="#ffd54a"; ctx.beginPath(); ctx.arc(x+16,y+16,8,0,Math.PI*2); ctx.fill(); }
          break;
        case T.FLAG:
          ctx.fillStyle="#888"; ctx.fillRect(x+14,y,4,TILE*2);
          ctx.fillStyle="#58a6ff"; ctx.beginPath(); ctx.moveTo(x+18,y+6); ctx.lineTo(x+48,y+14); ctx.lineTo(x+18,y+22); ctx.closePath(); ctx.fill(); break;
        case T.QBLOCK:
          ctx.fillStyle="#d6a11c"; ctx.fillRect(x,y,TILE,TILE);
          ctx.fillStyle="#000"; ctx.font="bold 18px system-ui"; ctx.textAlign="center"; ctx.fillText("?", x+TILE/2, y+20); break;
        case T.USED:
          ctx.fillStyle="#6b5b3e"; ctx.fillRect(x,y,TILE,TILE); break;
      }
    }
  }

  // ã‚¢ã‚¤ãƒ†ãƒ ï¼æ•µ
  for(const it of items){ it.draw?.(); }
  for(const e of enemies){ e.draw(); }

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
  drawPlayer();

  // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼ˆç„¡æ•µç‚¹æ»…ï¼‰
  if(player.starTimer>0){
    const t = player.starTimer;
    if((t>>3)%2===0){ ctx.fillStyle="rgba(255,255,255,.12)"; ctx.fillRect(0,0,view.w,view.h); }
  }
}

function drawPlayer(){
  const x=Math.floor(player.x-view.x), y=Math.floor(player.y-view.y);
  if(SPRITES.enabled && SPRITES.player.complete){
    // ç„¡æ•µæ™‚ã¯ç‚¹æ»…è‰²ã‚ªãƒ¼ãƒãƒ¬ã‚¤
    ctx.drawImage(SPRITES.player, x, y);
    if(player.starTimer>0){ ctx.globalCompositeOperation='screen'; ctx.fillStyle='rgba(255,240,120,.5)'; ctx.fillRect(x,y,player.w,player.h); ctx.globalCompositeOperation='source-over'; }
  }else{
    ctx.fillStyle= (player.starTimer>0 ? "#ffbf69" : "#ff6b6b");
    ctx.fillRect(x,y,player.w,player.h);
    ctx.fillStyle="#000"; ctx.fillRect(x+(player.facing>=0?14:4), y+6, 4,6);
  }
}

function drawSky(){ const g=ctx.createLinearGradient(0,0,0,view.h); g.addColorStop(0,"#0a1220"); g.addColorStop(1,"#0a0f14"); ctx.fillStyle=g; ctx.fillRect(0,0,view.w,view.h); }
function drawMountains(){ ctx.save(); ctx.translate(-view.x*0.3,-view.y*0.1); ctx.fillStyle="#101a2b";
  for(let i=0;i<8;i++){ const xx=i*300-100; ctx.beginPath(); ctx.moveTo(xx,view.h); ctx.lineTo(xx+120,view.h-150); ctx.lineTo(xx+240,view.h); ctx.closePath(); ctx.fill(); }
  ctx.restore(); }
function drawHills(){ ctx.save(); ctx.translate(-view.x*0.6,0); ctx.fillStyle="#0f1d2e";
  for(let i=0;i<12;i++){ const xx=i*180-60; ctx.beginPath(); ctx.ellipse(xx,view.h-20,120,30,0,0,Math.PI*2); ctx.fill(); }
  ctx.restore(); }

function drawBanner(text){
  draw(); ctx.fillStyle="rgba(0,0,0,.55)"; ctx.fillRect(0,0,view.w,view.h);
  ctx.fillStyle="#fff"; ctx.textAlign="center"; ctx.font="bold 26px system-ui"; ctx.fillText(text, view.w/2, view.h/2);
}
function drawPause(){ draw(); ctx.fillStyle="rgba(0,0,0,.35)"; ctx.fillRect(0,0,view.w,view.h);
  ctx.fillStyle="#fff"; ctx.textAlign="center"; ctx.font="bold 22px system-ui"; ctx.fillText("ä¸€æ™‚åœæ­¢ä¸­ - Pã§å†é–‹", view.w/2, view.h/2); }
function drawTitle(){
  drawSky(); drawMountains(); drawHills();
  ctx.fillStyle="#fff"; ctx.textAlign="center";
  ctx.font="bold 40px system-ui"; ctx.fillText("ãƒãƒªã‚ªé¢¨ æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«", view.w/2, view.h/2 - 40);
  ctx.font="16px system-ui";
  ctx.fillText("Enter ã¾ãŸã¯ ã‚¯ãƒªãƒƒã‚¯ã§ã‚¹ã‚¿ãƒ¼ãƒˆ", view.w/2, view.h/2 + 4);
  ctx.fillText("æ“ä½œï¼šâ†/â†’ãƒ»ã‚¹ãƒšãƒ¼ã‚¹ï¼ˆã‚¸ãƒ£ãƒ³ãƒ—ï¼‰ãƒ»Shift/Xï¼ˆãƒ€ãƒƒã‚·ãƒ¥ï¼‰", view.w/2, view.h/2 + 28);
}

/* =========================
   èµ·å‹•
   ========================= */
function startGame(){ if(gameState==='title'){ lives=3; score=0; loadLevel(0); paused=false; gameState='playing'; UI.refresh(); } }
addEventListener('keydown', e=>{ if((gameState==='over'||gameState==='clear') && e.key==='Enter'){ gameState='title'; } });
canvas.addEventListener('click', ()=>{ if(gameState==='over'||gameState==='clear'){ gameState='title'; } });

function boot(){ fitCanvas(); gameState='title'; UI.refresh(); requestAnimationFrame(update); }
boot();

})();
</script>
</body>
</html>
